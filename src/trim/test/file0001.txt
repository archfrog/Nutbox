//****************************************************************************
// Copyleft (-) 2008-2009 Mikael Lyngvig.  Donated to the Public Domain.
// THIS CODE IS PROVIDED AS IS AND WITHOUT ANY IMPLICIT OR EXPLICT WARRANTIES!
//****************************************************************************

using System.Reflection;

[assembly: AssemblyTitle("Nutbox.trim")]
[assembly: AssemblyDescription("Trims excess white-space off the end of lines.")]
[assembly: AssemblyConfiguration("SHIP")]
[assembly: AssemblyCompany("Mikael Lyngvig")]
[assembly: AssemblyProduct("Nutbox")]
[assembly: AssemblyCopyright("Copyleft (-) 2009 Mikael Lyngvig")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]
[assembly: AssemblyVersion("0.8.8.0")]
[assembly: AssemblyDelaySign(false)]
[assembly: AssemblyKeyName("")]
[assembly: System.CLSCompliant(true)]

namespace Nutbox.Trim
{
	using System.Collections.Generic;	// List<string>

    class Setup: Nutbox.Setup
    {
		public List<string> Wildcards = new List<string>();
		public bool Recurse   = false;	// true => recurse subdirectories

        public override void Check()
        {
        }

		public override ParseResult ParseOption(string name, string data)
		{
			if (data != null)
				return ParseResult.Extranous;

			switch (name)
			{
				case "RECURSE":
					Recurse = true;
					break;

				case "NORECURSE":
					Recurse = false;
					break;

				default:
					return ParseResult.Unknown;
			}

			return ParseResult.Success;
		}

        public override ParseResult ParseParameter(string arg)
        {
			Wildcards.Add(arg);
			return ParseResult.Success;
        }
    }

    class Program: Nutbox.Program
    {
		static string[] _help =
		{
			"Trims excess white-space off the end of lines.",
			"",
			"Options:",
			"",
			"    -recurse   Recurse subdirectories.",
			"",
			"Tip: 'trim' only updates the file if a change was made."
		};

		static Nutbox.Information _info = new Nutbox.Information(
			"trim",						// Program
			"v1.00",					// Version
			Nutbox.Copyright.Company,	// Company
			Nutbox.Copyright.Rights,	// Rights
			Nutbox.Copyright.Support,	// Support
			"*option *wildcard", 		// Syntax
			_help,						// Help
			2009,						// Lower
			2009						// Upper
		);

		public Program(): base(_info)
		{
		}

        public override void Main(Nutbox.Setup Nutbox_setup)
        {
			Setup setup = (Setup) Nutbox_setup;

			// expand wildcards
			string[] wildcards = new string[setup.Wildcards.Count];
			setup.Wildcards.CopyTo(wildcards, 0);
			string[] files = Nutbox.Platform.File.Find(wildcards, setup.Recurse);

			// check that each specified and found file actually exists
			foreach (string file in files)
			{
				if (!System.IO.File.Exists(file))
					throw new Nutbox.Exception("File not found: " + file);
			}

			// iterate over each file and trim it
			foreach (string file in files)
			{
				System.IO.StreamReader reader = new System.IO.StreamReader(file);
				List<string> lines  = new List<string>();

				// iterate until no more lines
				bool changed = false;
				for (;;)
				{
					// read a line and exit the loop if no more lines
					string line = reader.ReadLine();
					if (line == null)
						break;

					// trim the trailing white-space off the line
					string trimmed = line.TrimEnd();
					if (line != trimmed)
						changed = true;

					// cache the result
					lines.Add(trimmed);
				}

				// clean up (required to get access to the file)
				reader.Close();

				// only write the file if it has been changed
				if (changed)
				{
					System.IO.StreamWriter writer = new System.IO.StreamWriter(file);

					// write the trimmed lines to the output file
					foreach (string line in lines)
						writer.WriteLine(line);

					// yup, let's not rely too much on the destructor
					writer.Close();
				}
			}
		}

		public static int Main(string[] args)
		{
			Setup setup     = new Setup();
			Program program = new Program();

			// let Nutbox.Program.Main() handle exceptions, etc.
			return program.Main(setup, args);
		}
    }
}
